// Copyright 2022 saikocat (@saikocat)
// SPDX-License-Identifier: GPL-2.0-or-later

#include QMK_KEYBOARD_H

#include "sync_timer.h"

// clang-format off
enum layer {
    _QWERTY = 0,
    _COLEMAK_DH,
    _GAME_OVERWATCH,
    _GAME_NUMPAD,

    _LOWER,
    _RAISE,
    _NAV_LEFT,
    _NUMPAD,
    _ADJUST,

    _SPECIAL,

    _SYMBOL = _LOWER,
    _NAV    = _RAISE,
    _FUNC   = _ADJUST,
};

enum userspace_custom_keycodes {
    QMK_BEST = SAFE_RANGE,

    UK_BRACES,
    UK_CLEAR,
    UK_REPEAT,

    DEL_LWR  = LT(_LOWER,   KC_DEL),
    ENT_NUM  = LT(_NUMPAD,  KC_ENT),
    BSPC_NUM = LT(_NUMPAD,  KC_BSPC),
    TAB_RSE  = LT(_RAISE,   KC_TAB),
    ESC_ADJ  = LT(_ADJUST,  KC_ESC),
    ENT_ADJ  = LT(_ADJUST,  KC_ENT),

    DEL_ALT  = MT(MOD_LALT, KC_DEL),
    ENT_ALT  = MT(MOD_LALT, KC_ENT),
    ESC_ALT  = MT(MOD_LALT, KC_ESC),
    QUOT_CTL = MT(MOD_RCTL, KC_QUOTE),
    BSPC_SFT = MT(MOD_LSFT, KC_BSPC),
    ENT_SFT  = MT(MOD_RSFT, KC_ENTER),

    OSM_LGUI = OSM(MOD_LGUI),
    OSM_LALT = OSM(MOD_LALT),
    OSM_LSFT = OSM(MOD_LSFT),
    OSM_LCTL = OSM(MOD_LCTL),

    NEW_SAFE_RANGE,
};

// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_QWERTY] = LAYOUT_split_3x6_3(
        KC_TAB,   KC_Q,     KC_W,     KC_E,     KC_R,     KC_T,               KC_Y,     KC_U,     KC_I,     KC_O,     KC_P,     KC_BSPC,
        KC_LCTL,  KC_A,     KC_S,     KC_D,     KC_F,     KC_G,               KC_H,     KC_J,     KC_K,     KC_L,     KC_SCLN,  QUOT_CTL,
        OSM_LALT, KC_Z,     KC_X,     KC_C,     KC_V,     KC_B,               KC_N,     KC_M,     KC_COMM,  KC_DOT,   KC_SLSH,  RSFT_T(KC_ENT),
                                   DEL_LWR, BSPC_NUM,     OSM_LSFT,           ENT_ADJ,  KC_SPC,   TAB_RSE
    ),

    [_COLEMAK_DH] = LAYOUT_split_3x6_3(
        KC_TAB,   KC_Q,     KC_W,     KC_F,     KC_P,     KC_B,               KC_J,     KC_L,     KC_U,     KC_Y,     KC_SCLN,  KC_BSPC,
        OSM_LCTL, KC_A,     KC_R,     KC_S,     KC_T,     KC_G,               KC_M,     KC_N,     KC_E,     KC_I,     KC_O,     QUOT_CTL,
        OSM_LALT, KC_Z,     KC_X,     KC_C,     KC_D,     KC_V,               KC_K,     KC_H,     KC_COMM,  KC_DOT,   KC_SLSH,  ENT_SFT,
                                   DEL_LWR, BSPC_NUM,     OSM_LSFT,           ENT_ADJ,  KC_SPC,   TAB_RSE
    ),

    [_GAME_OVERWATCH] = LAYOUT_split_3x6_3(
        KC_T,     KC_TAB,   KC_Q,     KC_W,     KC_E,     KC_R,               KC_Y,     KC_U,     KC_I,     KC_O,     KC_P,     KC_BSPC,
        KC_G,     KC_LCTL,  KC_A,     KC_S,     KC_D,     KC_F,               KC_H,     KC_J,     KC_K,     KC_L,     KC_SCLN,  QUOT_CTL,
        KC_B,     KC_LSFT,  KC_Z,     KC_X,     KC_C,     KC_V,               KC_N,     KC_M,     KC_COMM,  KC_DOT,   KC_SLSH,  RSFT_T(KC_ENT),
                              MO(_GAME_NUMPAD), KC_SPC,   ESC_ALT,            ENT_ADJ,  KC_ESC,   TAB_RSE
    ),

    [_GAME_NUMPAD] = LAYOUT_split_3x6_3(
        KC_ESC,   C(KC_3),  C(KC_2),  C(KC_1),  C(KC_0),  C(KC_4),            _______,  _______,  _______,  _______,  _______,  _______,
        KC_LCTL,  KC_3,     KC_2,     KC_1,     KC_0,     KC_4,               _______,  _______,  _______,  _______,  _______,  _______,
        ENT_SFT,  KC_F3,    KC_F2,    KC_F1,    KC_F4,    KC_F5,              _______,  _______,  _______,  _______,  _______,  _______,
                                      _______,  _______,  _______,            _______,  _______,  _______
    ),

    [_LOWER] = LAYOUT_split_3x6_3(
        KC_ESC,   KC_QUOT,  KC_LT,    KC_GT,    KC_DQUO,  UK_BRACES,          KC_AMPR,  KC_UNDS,  KC_LBRC,  KC_RBRC,  KC_PERC,  UK_CLEAR,
        _______,  KC_EXLM,  KC_MINS,  KC_PLUS,  KC_EQL ,  KC_HASH,            KC_PIPE,  KC_COLN,  KC_LPRN,  KC_RPRN,  KC_QUES,  _______,
        _______,  KC_BSLS,  KC_SLSH,  KC_ASTR,  KC_CIRC,  KC_GRV,             KC_TILD,  KC_DLR ,  KC_LCBR,  KC_RCBR,  KC_AT,    _______,
                                      _______,  _______,  _______,            _______,  KC_ENT,   MO(_SPECIAL)
    ),

    [_RAISE] = LAYOUT_split_3x6_3(
        _______,  _______,     C(KC_W),     _______,       CW_TOGG,    G(KC_SPC),        DF(_QWERTY),  DF(_COLEMAK_DH),  DF(_NAV),  DF(_GAME_OVERWATCH),  KC_PSCR, _______,
        _______,  C(KC_LEFT),  C(KC_RGHT),  C(S(KC_TAB)),  C(KC_TAB),  CM_TOGG,          KC_LEFT,      KC_DOWN,          KC_UP,     KC_RGHT,    KC_INS,   _______,
        _______,  C(KC_Z),     C(KC_X),     C(KC_C),       A(KC_ESC),  C(KC_V),          KC_HOME,      KC_PGDN,          KC_PGUP,   KC_END,     DF(_NAV_LEFT), _______,
                                              MO(_SPECIAL),  _______,  _______,          _______,  _______,  _______
    ),

    [_NAV_LEFT] = LAYOUT_split_3x6_3(
        _______,  _______,     _______,  KC_UP,    _______,   _______,          DF(_QWERTY),  DF(_COLEMAK_DH),  DF(_NAV),  DF(_GAME_OVERWATCH),  _______, _______,
        _______,  S(KC_LEFT),  KC_LEFT,  KC_DOWN,  KC_RIGHT,  S(KC_RIGHT),      KC_LEFT,      KC_DOWN,          KC_UP,     KC_RGHT,    KC_INS,   _______,
        _______,  _______,     _______,  _______,  _______,   _______,          KC_HOME,      KC_PGDN,          KC_PGUP,   KC_END,     _______,  _______,
                                     MO(_SPECIAL),  _______,  _______,          _______,  _______,  _______
    ),

    [_NUMPAD] = LAYOUT_split_3x6_3(
        _______,  _______,  _______,  _______,  _______,  _______,            KC_PAST,  KC_7,     KC_8,     KC_9,     KC_EQL,   _______,
        _______,  KC_LGUI,  KC_LALT,  KC_LSFT,  KC_LCTL,  _______,            KC_P0,    KC_4,     KC_5,     KC_6,     KC_PPLS,  _______,
        _______,  _______,  _______,  _______,  _______,  _______,            KC_PSLS,  KC_1,     KC_2,     KC_3,     KC_PMNS,  _______,
                                      _______,  _______,  _______,            KC_ENT,   KC_0,     KC_PDOT
    ),

    [_FUNC] = LAYOUT_split_3x6_3(
        _______,  _______,  _______,  _______,  _______,  _______,            _______,  KC_F7,    KC_F8,    KC_F9,    KC_F10,   _______,
        _______,  KC_LGUI,  KC_LALT,  KC_LSFT,  KC_LCTL,  _______,            _______,  KC_F4,    KC_F5,    KC_F6,    KC_F11,   _______,
        _______,  _______,  _______,  _______,  _______,  _______,            _______,  KC_F1,    KC_F2,    KC_F3,    KC_F12,   _______,
                                      _______,  _______,  _______,            _______,  _______,  _______
    ),

    [_SPECIAL] = LAYOUT_split_3x6_3(
        XXXXXXX,  QK_BOOT,  EE_CLR,   XXXXXXX,  XXXXXXX,  XXXXXXX,            RGB_VAI,  RGB_SAI,  RGB_HUI,  RGB_MOD,  RGB_TOG,  XXXXXXX,
        XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,            RGB_VAD,  RGB_SAD,  RGB_HUD,  RGB_RMOD, XXXXXXX,  XXXXXXX,
        XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,            XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,  XXXXXXX,
                                      _______,  _______,  _______,            _______,  _______,  _______
    ),
};

// clang-format on

/*
 * Repeat function
 * https://gist.github.com/NotGate/3e3d8ab81300a86522b2c2549f99b131
 * Used to extract the basic tapping keycode from a dual-role key.
 * Example: GET_TAP_KC(MT(MOD_RSFT, KC_E)) == KC_E
 */
#define GET_TAP_KC(dual_role_key) dual_role_key & 0xFF
uint16_t last_keycode     = KC_NO;
uint8_t  last_modifier    = 0;
uint16_t pressed_keycode  = KC_NO;
uint16_t pressed_modifier = 0;

bool process_repeat_key(uint16_t keycode, const keyrecord_t *record) {
    if (keycode != UK_REPEAT) {
        // Early return when holding down a pure layer key
        // to retain modifiers
        switch (keycode) {
            case QK_DEF_LAYER ... QK_DEF_LAYER_MAX:
            case QK_MOMENTARY ... QK_MOMENTARY_MAX:
            case QK_LAYER_MOD ... QK_LAYER_MOD_MAX:
            case QK_ONE_SHOT_LAYER ... QK_ONE_SHOT_LAYER_MAX:
            case QK_TOGGLE_LAYER ... QK_TOGGLE_LAYER_MAX:
            case QK_TO ... QK_TO_MAX:
            case QK_LAYER_TAP_TOGGLE ... QK_LAYER_TAP_TOGGLE_MAX:
            case QK_MODS ... QK_MODS_MAX:
                return true;
        }
        if (record->event.pressed) {
            last_modifier = get_mods() | get_oneshot_mods();
            switch (keycode) {
                case QK_LAYER_TAP ... QK_LAYER_TAP_MAX:
                case QK_MOD_TAP ... QK_MOD_TAP_MAX:
                    last_keycode = GET_TAP_KC(keycode);
                    break;
                default:
                    last_keycode = keycode;
                    break;
            }
        }
    } else { // keycode == UK_REPEAT
        if (record->event.pressed) {
            pressed_keycode  = last_keycode;
            pressed_modifier = last_modifier;
            register_mods(pressed_modifier);
            register_code16(pressed_keycode);
            unregister_mods(pressed_modifier);
        } else {
            unregister_code16(pressed_keycode);
        }
        return false;
    }
    return true;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    const uint8_t mods         = get_mods();
    const uint8_t oneshot_mods = get_oneshot_mods();

    // process_record_user_oled(keycode, record);
    process_repeat_key(keycode, record);

    switch (keycode) {
        case UK_BRACES: // Types [], {}, or () and puts cursor between braces.
            if (record->event.pressed) {
                clear_mods();
                clear_oneshot_mods();
                if ((mods | oneshot_mods) & MOD_MASK_SHIFT) {
                    SEND_STRING("{}");
                } else if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                    SEND_STRING("[]");
                } else {
                    SEND_STRING("()");
                }
                tap_code(KC_LEFT);             // Move cursor between braces.
                set_mods(mods | oneshot_mods); // Restore mods.
            }
            return false;
        case UK_CLEAR:
            clear_mods();
            clear_oneshot_mods();
            return false;
    }
    return true;
}

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    return TAPPING_TERM;
}

bool get_hold_on_other_key_press(uint16_t keycode, keyrecord_t *record) {
    // Immediately select the hold action when another key is pressed (tapped and released)
    // return true;
    // Do not select the hold action when another key is pressed.
    // return false;
    switch (keycode) {
        case BSPC_NUM:
        case ENT_NUM:
        case BSPC_SFT:
        case DEL_LWR:
        case DEL_ALT:
        case ENT_ALT:
        case ESC_ALT:
        case ESC_ADJ:
        case ENT_ADJ:
        case TAB_RSE:
            return true;
        default:
            return false;
    }
}

bool get_permissive_hold(uint16_t keycode, keyrecord_t *record) {
    // Immediately select the hold action when another key is tapped:
    // return true;
    // Do not select the hold action when another key is tapped.
    // return false;
    switch (keycode) {
        case BSPC_NUM:
        case ENT_NUM:
        case BSPC_SFT:
        case DEL_LWR:
        case DEL_ALT:
        case ENT_SFT:
        case ENT_ALT:
        case ESC_ADJ:
        case ENT_ADJ:
        case ESC_ALT:
        case TAB_RSE:
            return true;
        default:
            return false;
    }
}

bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) {
    // Do not force the mod-tap key press to be handled as a modifier
    // if any other key was pressed while the mod-tap key is held down.
    // return true;
    // Force the mod-tap key press to be handled as a modifier if any
    // other key was pressed while the mod-tap key is held down.
    // return false;
    switch (keycode) {
        case QUOT_CTL:
            return true;
        default:
            return false;
    }
}

bool get_tapping_force_hold(uint16_t keycode, keyrecord_t *record) {
    // Disable repeated tapping
    switch (keycode) {
        case QUOT_CTL:
        case DEL_ALT:
        case ENT_ALT:
        case ESC_ALT:
        case TAB_RSE:
            return true;
        default:
            return false;
    }
}

bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) {
    // Output keycode regardless after hold is done
    switch (keycode) {
        default:
            return false;
    }
}

/* Capsword */
void caps_word_set_user(bool active) {}

bool caps_word_press_user(uint16_t keycode) {
    switch (keycode) {
        // Keycodes that continue Caps Word, with shift applied.
        case KC_A ... KC_Z:
            add_weak_mods(MOD_BIT(KC_LSFT)); // Apply shift to the next key.
            return true;

        // Keycodes that continue Caps Word, without shifting.
        case KC_1 ... KC_0:
        case KC_BSPC:
        case KC_MINS:
        case KC_UNDS:
            return true;

        default:
            return false; // Deactivate Caps Word.
    }
}

/* Combos */
#include "combo_gboards.h"

/* Gaming settings */
layer_state_t layer_state_set_user(layer_state_t state) {
    switch (get_highest_layer(default_layer_state)) {
        case _GAME_OVERWATCH:
        case _GAME_NUMPAD:
#ifdef CAPS_WORD_ENABLE
            caps_word_off();
#endif
#ifdef COMBO_ENABLE
            combo_disable();
#endif
            break;
        default:
#ifdef COMBO_ENABLE
            combo_enable();
#endif
    }

    return state;
}

#define IDLE_FRAMES 5
#define TAP_FRAMES 2
#define FRAME_DURATION 200 // milliseconds
#define TAP_INTERVAL FRAME_DURATION * 2
#define PAWS_INTERVAL FRAME_DURATION * 8

// Timer duration between key presses
uint32_t oled_tap_timer = 0;

// Run-length encoded animation frames
// Right frames
static unsigned char const  idle0[] PROGMEM   = {144, 0x3a, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x05, 0x10, 0x02, 0x08, 0x03, 0x04, 0x84, 0x08, 0x30, 0x40, 0x80, 0x2e, 0x00, 0x03, 0x80, 0x31, 0x00, 0x83, 0x18, 0x64, 0x82, 0x05, 0x02, 0x01, 0x01, 0x04, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x82, 0x00, 0xc0, 0x02, 0xc1, 0x87, 0xc2, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x03, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0xc0, 0x38, 0x04, 0x03, 0x07, 0x00, 0x03, 0x0c, 0x88, 0x0d, 0x01, 0x00, 0x40, 0xa0, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x02, 0x04, 0x02, 0x08, 0x05, 0x10, 0x82, 0x11, 0x0f, 0x02, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x02, 0x04, 0x05, 0x08, 0x01, 0x07, 0x3d, 0x00};
static unsigned char const  idle1[] PROGMEM   = {147, 0x3a, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x04, 0x10, 0x02, 0x08, 0x01, 0x04, 0x03, 0x02, 0x84, 0x04, 0x38, 0x40, 0x80, 0x2e, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x1c, 0xe2, 0x02, 0x01, 0x04, 0x02, 0x01, 0x01, 0x04, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x82, 0x00, 0xc0, 0x02, 0xc1, 0x87, 0xc2, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x03, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x0c, 0x03, 0x07, 0x00, 0x03, 0x0c, 0x88, 0x0d, 0x01, 0x00, 0x40, 0xa0, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x02, 0x04, 0x02, 0x08, 0x05, 0x10, 0x82, 0x11, 0x0f, 0x02, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x02, 0x04, 0x05, 0x08, 0x01, 0x07, 0x3d, 0x00};
static unsigned char const  idle2[] PROGMEM   = {154, 0x33, 0x00, 0x02, 0x80, 0x05, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x04, 0x10, 0x83, 0x08, 0x04, 0x02, 0x02, 0x01, 0x85, 0x02, 0x0c, 0x30, 0x40, 0x80, 0x2e, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x1e, 0xe1, 0x02, 0x00, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x04, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x82, 0x00, 0xc0, 0x02, 0xc1, 0x87, 0xc2, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x03, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x0c, 0x03, 0x07, 0x00, 0x03, 0x0c, 0x88, 0x0d, 0x01, 0x00, 0x40, 0xa0, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x02, 0x04, 0x02, 0x08, 0x05, 0x10, 0x82, 0x11, 0x0f, 0x02, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x02, 0x04, 0x05, 0x08, 0x01, 0x07, 0x3d, 0x00};
static unsigned char const  idle3[] PROGMEM   = {140, 0x3b, 0x00, 0x02, 0x80, 0x04, 0x40, 0x04, 0x20, 0x83, 0x10, 0x08, 0x04, 0x02, 0x02, 0x84, 0x04, 0x18, 0x60, 0x80, 0x2f, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x3c, 0xc2, 0x02, 0x01, 0x02, 0x02, 0x02, 0x04, 0x82, 0x02, 0x01, 0x10, 0x00, 0x02, 0x60, 0x82, 0x00, 0x81, 0x02, 0x82, 0x86, 0x84, 0x08, 0x10, 0x20, 0x40, 0x80, 0x04, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x19, 0x06, 0x07, 0x00, 0x03, 0x18, 0x88, 0x1b, 0x03, 0x00, 0x40, 0xa0, 0x22, 0x24, 0x14, 0x03, 0x12, 0x01, 0x0b, 0x04, 0x08, 0x02, 0x05, 0x02, 0x09, 0x05, 0x10, 0x82, 0x11, 0x0f, 0x02, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x02, 0x04, 0x05, 0x08, 0x01, 0x07, 0x3d, 0x00};
static unsigned char const *idle[IDLE_FRAMES] = {idle0, idle0, idle1, idle2, idle3};

static unsigned char const paws[] PROGMEM = {150, 0x33, 0x00, 0x02, 0x80, 0x05, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x04, 0x10, 0x83, 0x08, 0x04, 0x02, 0x02, 0x01, 0x85, 0x02, 0x0c, 0x30, 0x40, 0x80, 0x2e, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x1e, 0xe1, 0x02, 0x00, 0x02, 0x01, 0x02, 0x02, 0x01, 0x81, 0x02, 0x80, 0x02, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x02, 0x00, 0x8a, 0x01, 0xe1, 0x1a, 0x06, 0x09, 0x31, 0x35, 0x01, 0x8a, 0x7c, 0x02, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x0c, 0x03, 0x02, 0x00, 0x88, 0x18, 0x06, 0x05, 0x98, 0x99, 0x84, 0xc3, 0x7c, 0x02, 0x41, 0x02, 0x40, 0x84, 0x20, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x06, 0x04, 0x03, 0x02, 0x04, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x47, 0x00};

static unsigned char const  tap0[] PROGMEM  = {180,  0x33, 0x00, 0x02, 0x80, 0x05, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x04, 0x10, 0x83, 0x08, 0x04, 0x02, 0x02, 0x01, 0x85, 0x02, 0x0c, 0x30, 0x40, 0x80, 0x07, 0x00, 0x04, 0xf8, 0x05, 0x00, 0x02, 0x80, 0x1c, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x1e, 0xe1, 0x02, 0x00, 0x02, 0x01, 0x02, 0x02, 0x01, 0x81, 0x02, 0x80, 0x02, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x02, 0x00, 0x02, 0x01, 0x8e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x43, 0x87, 0x07, 0x01, 0x00, 0xb8, 0xbc, 0xbe, 0x9f, 0x02, 0x5f, 0x82, 0x4f, 0x4c, 0x04,
                                               0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x0c, 0x03, 0x02, 0x00, 0x88, 0x18, 0x06, 0x05, 0x98, 0x99, 0x84, 0x43, 0x7c, 0x02, 0x41, 0x02, 0x40, 0x84, 0x20, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x02, 0x04, 0x02, 0x08, 0x05, 0x10, 0x85, 0x11, 0x0f, 0x01, 0x3d, 0x7c, 0x05, 0xfc, 0x82, 0x3c, 0x0c, 0x2e, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x02, 0x06, 0x01, 0x24, 0x00, 0x01, 0x01, 0x02, 0x03, 0x20, 0x00};
static unsigned char const  tap1[] PROGMEM  = {153, 0x33, 0x00, 0x02, 0x80, 0x05, 0x00, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x04, 0x10, 0x83, 0x08, 0x04, 0x02, 0x02, 0x01, 0x85, 0x02, 0x0c, 0x30, 0x40, 0x80, 0x2e, 0x00, 0x03, 0x80, 0x31, 0x00, 0x82, 0x1e, 0xe1, 0x02, 0x00, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x04, 0x00, 0x02, 0x80, 0x09, 0x00, 0x82, 0x80, 0x00, 0x02, 0x30, 0x02, 0x00, 0x8a, 0x01, 0xe1, 0x1a, 0x06, 0x09, 0x31, 0x35, 0x01, 0x8a, 0x7c, 0x02, 0x00, 0x04, 0x80, 0x04, 0x40, 0x04, 0x20, 0x04, 0x10, 0x05, 0x08, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x33, 0x00, 0x84, 0x80, 0x70, 0x0c, 0x03, 0x0a, 0x00, 0x02, 0x01, 0x86, 0x00, 0x40, 0xa0, 0x21, 0x22, 0x12, 0x03, 0x11, 0x01, 0x09, 0x04, 0x08, 0x06, 0x04, 0x03, 0x02, 0x04, 0x01, 0x36, 0x00, 0x05, 0x80, 0x05, 0x40, 0x05, 0x20, 0x05, 0x10, 0x05, 0x08, 0x05, 0x04, 0x82, 0x02, 0x03, 0x02, 0x7a, 0x04, 0x79, 0x82, 0x39, 0x31, 0x02, 0x02, 0x02, 0x04, 0x03, 0x08, 0x02, 0x88, 0x82, 0x87, 0x80, 0x3c, 0x00};
static unsigned char const *tap[TAP_FRAMES] = {tap0, tap1};

// Left frames
static unsigned char const  left_idle0[] PROGMEM   = {142, 0x03, 0x80, 0x2e, 0x00, 0x84, 0x80, 0x40, 0x30, 0x08, 0x03, 0x04, 0x02, 0x08, 0x05, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x3d, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x03, 0x00, 0x87, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0xc2, 0x02, 0xc1, 0x82, 0xc0, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x04, 0x00, 0x01, 0x01, 0x05, 0x02, 0x83, 0x82, 0x64, 0x18, 0x56, 0x00, 0x02, 0x01, 0x82, 0x0f, 0x11, 0x05, 0x10, 0x02, 0x08, 0x02, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x88, 0x12, 0x22, 0x21, 0xa0, 0x40, 0x00, 0x01, 0x0d, 0x03, 0x0c, 0x07, 0x00, 0x84, 0x03, 0x04, 0x38, 0xc0, 0x6d, 0x00, 0x01, 0x07, 0x05, 0x08, 0x02, 0x04, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const  left_idle1[] PROGMEM   = {145, 0x03, 0x80, 0x2e, 0x00, 0x84, 0x80, 0x40, 0x38, 0x04, 0x03, 0x02, 0x01, 0x04, 0x02, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x3d, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x03, 0x00, 0x87, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0xc2, 0x02, 0xc1, 0x82, 0xc0, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x04, 0x00, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x82, 0xe2, 0x1c, 0x56, 0x00, 0x02, 0x01, 0x82, 0x0f, 0x11, 0x05, 0x10, 0x02, 0x08, 0x02, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x88, 0x12, 0x22, 0x21, 0xa0, 0x40, 0x00, 0x01, 0x0d, 0x03, 0x0c, 0x07, 0x00, 0x84, 0x03, 0x0c, 0x70, 0x80, 0x6d, 0x00, 0x01, 0x07, 0x05, 0x08, 0x02, 0x04, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const  left_idle2[] PROGMEM   = {152, 0x03, 0x80, 0x2e, 0x00, 0x85, 0x80, 0x40, 0x30, 0x0c, 0x02, 0x02, 0x01, 0x83, 0x02, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x05, 0x00, 0x02, 0x80, 0x36, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x03, 0x00, 0x87, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0xc2, 0x02, 0xc1, 0x82, 0xc0, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x04, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x02, 0x00, 0x82, 0xe1, 0x1e, 0x56, 0x00, 0x02, 0x01, 0x82, 0x0f, 0x11, 0x05, 0x10, 0x02, 0x08, 0x02, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x88, 0x12, 0x22, 0x21, 0xa0, 0x40, 0x00, 0x01, 0x0d, 0x03, 0x0c, 0x07, 0x00, 0x84, 0x03, 0x0c, 0x70, 0x80, 0x6d, 0x00, 0x01, 0x07, 0x05, 0x08, 0x02, 0x04, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const  left_idle3[] PROGMEM   = {138, 0x03, 0x80, 0x2f, 0x00, 0x84, 0x80, 0x60, 0x18, 0x04, 0x02, 0x02, 0x83, 0x04, 0x08, 0x10, 0x04, 0x20, 0x04, 0x40, 0x02, 0x80, 0x3e, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x04, 0x00, 0x86, 0x80, 0x40, 0x20, 0x10, 0x08, 0x84, 0x02, 0x82, 0x82, 0x81, 0x00, 0x02, 0x60, 0x10, 0x00, 0x82, 0x01, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x82, 0xc2, 0x3c, 0x56, 0x00, 0x02, 0x01, 0x82, 0x0f, 0x11, 0x05, 0x10, 0x02, 0x09, 0x02, 0x05, 0x04, 0x08, 0x01, 0x0b, 0x03, 0x12, 0x88, 0x14, 0x24, 0x22, 0xa0, 0x40, 0x00, 0x03, 0x1b, 0x03, 0x18, 0x07, 0x00, 0x84, 0x06, 0x19, 0x70, 0x80, 0x6d, 0x00, 0x01, 0x07, 0x05, 0x08, 0x02, 0x04, 0x02, 0x02, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const *left_idle[IDLE_FRAMES] = {left_idle0, left_idle0, left_idle1, left_idle2, left_idle3};

static unsigned char const left_paws[] PROGMEM = {148, 0x03, 0x80, 0x2e, 0x00, 0x85, 0x80, 0x40, 0x30, 0x0c, 0x02, 0x02, 0x01, 0x83, 0x02, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x05, 0x00, 0x02, 0x80, 0x36, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x02, 0x00, 0x8a, 0x7c, 0x8a, 0x01, 0x35, 0x31, 0x09, 0x06, 0x1a, 0xe1, 0x01, 0x02, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x02, 0x00, 0x02, 0x80, 0x01, 0x81, 0x02, 0x02, 0x02, 0x01, 0x02, 0x00, 0x82, 0xe1, 0x1e, 0x56, 0x00, 0x04, 0x01, 0x03, 0x02, 0x06, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x84, 0x12, 0x22, 0x21, 0x20, 0x02, 0x40, 0x02, 0x41, 0x88, 0x7c, 0xc3, 0x84, 0x99, 0x98, 0x05, 0x06, 0x18, 0x02, 0x00, 0x84, 0x03, 0x0c, 0x70, 0x80, 0x77, 0x00, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};

static unsigned char const  left_tap0[] PROGMEM  = {178,  0x03, 0x80, 0x1c, 0x00, 0x02, 0x80, 0x05, 0x00, 0x04, 0xf8, 0x07, 0x00, 0x85, 0x80, 0x40, 0x30, 0x0c, 0x02, 0x02, 0x01, 0x83, 0x02, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x05, 0x00, 0x02, 0x80, 0x36, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x82, 0x4c, 0x4f, 0x02, 0x5f, 0x8e, 0x9f, 0xbe, 0xbc, 0xb8, 0x00, 0x01, 0x07, 0x87, 0x43, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x01, 0x02, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x02, 0x00, 0x02, 0x80, 0x01,
                                                    0x81, 0x02, 0x02, 0x02, 0x01, 0x02, 0x00, 0x82, 0xe1, 0x1e, 0x4e, 0x00, 0x82, 0x0c, 0x3c, 0x05, 0xfc, 0x85, 0x7c, 0x3d, 0x01, 0x0f, 0x11, 0x05, 0x10, 0x02, 0x08, 0x02, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x84, 0x12, 0x22, 0x21, 0x20, 0x02, 0x40, 0x02, 0x41, 0x88, 0x7c, 0x43, 0x84, 0x99, 0x98, 0x05, 0x06, 0x18, 0x02, 0x00, 0x84, 0x03, 0x0c, 0x70, 0x80, 0x50, 0x00, 0x02, 0x03, 0x01, 0x01, 0x24, 0x00, 0x06, 0x01, 0x02, 0x02, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const  left_tap1[] PROGMEM  = {151, 0x03, 0x80, 0x2e, 0x00, 0x85, 0x80, 0x40, 0x30, 0x0c, 0x02, 0x02, 0x01, 0x83, 0x02, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80, 0x05, 0x00, 0x02, 0x80, 0x36, 0x00, 0x04, 0x01, 0x04, 0x02, 0x05, 0x04, 0x05, 0x08, 0x04, 0x10, 0x04, 0x20, 0x04, 0x40, 0x04, 0x80, 0x02, 0x00, 0x8a, 0x7c, 0x8a, 0x01, 0x35, 0x31, 0x09, 0x06, 0x1a, 0xe1, 0x01, 0x02, 0x00, 0x02, 0x30, 0x82, 0x00, 0x80, 0x09, 0x00, 0x02, 0x80, 0x04, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x02, 0x00, 0x82, 0xe1, 0x1e, 0x56, 0x00, 0x04, 0x01, 0x03, 0x02, 0x06, 0x04, 0x04, 0x08, 0x01, 0x09, 0x03, 0x11, 0x86, 0x12, 0x22, 0x21, 0xa0, 0x40, 0x00, 0x02, 0x01, 0x0a, 0x00, 0x84, 0x03, 0x0c, 0x70, 0x80, 0x6c, 0x00, 0x82, 0x80, 0x87, 0x02, 0x88, 0x03, 0x08, 0x02, 0x04, 0x02, 0x02, 0x82, 0x31, 0x39, 0x04, 0x79, 0x02, 0x7a, 0x82, 0x03, 0x02, 0x05, 0x04, 0x05, 0x08, 0x05, 0x10, 0x05, 0x20, 0x05, 0x40, 0x05, 0x80, 0x11, 0x00};
static unsigned char const *left_tap[TAP_FRAMES] = {left_tap0, left_tap1};

// RLE decoding loop that reads count from frame index
// If count >= 0x80, next (count - 128) bytes are unique
// If count < 0x80, next byte is repeated by count
static void decode_frame(unsigned char const *frame) {
    uint16_t cursor = 0;
    uint8_t  size   = pgm_read_byte(frame);
    uint8_t  i      = 1;

    oled_set_cursor(0, 0);
    while (i < size) {
        uint8_t count = pgm_read_byte(frame + i);
        i++;
        if (count & 0x80) {
            // Next count-128 bytes are unique
            count &= ~(0x80);
            for (uint8_t uniqs = 0; uniqs < count; ++uniqs) {
                uint8_t byte = pgm_read_byte(frame + i);
                i++;
                oled_write_raw_byte(byte, cursor++);
            }
        } else {
            // Next byte is repeated by count
            uint8_t byte = pgm_read_byte(frame + i);
            i++;
            for (uint8_t reps = 0; reps < count; ++reps) {
                oled_write_raw_byte(byte, cursor++);
            }
        }
    }
}

void animate_cat(void) {
    static uint8_t tap_index  = 0;
    static uint8_t idle_index = 0;

    if (timer_elapsed32(oled_tap_timer) < TAP_INTERVAL) {
        tap_index = (tap_index + 1) & 1;
        decode_frame(is_keyboard_left() ? left_tap[tap_index] : tap[tap_index]);
    } else if (timer_elapsed32(oled_tap_timer) < PAWS_INTERVAL) {
        decode_frame(is_keyboard_left() ? left_paws : paws);
    } else {
        idle_index = idle_index < IDLE_FRAMES - 1 ? idle_index + 1 : 0;
        decode_frame(is_keyboard_left() ? left_idle[idle_index] : idle[idle_index]);
    }
}

static void render_bongocat(void) {
    // Timer duration between animation frames
    static uint16_t anim_timer = 0;

#ifdef WPM_ENABLE
    static uint8_t prev_wpm = 0;
    // Update oled_tap_timer with sustained WPM
    if (get_current_wpm() > prev_wpm) {
        oled_tap_timer = timer_read32();
    }
    prev_wpm = get_current_wpm();
#endif

    if (timer_elapsed32(oled_tap_timer) > OLED_TIMEOUT) {
        oled_off();
    } else if (timer_elapsed(anim_timer) > FRAME_DURATION) {
        anim_timer = timer_read();
        animate_cat();
    }
}

// Init and rendering calls
oled_rotation_t oled_init_user(oled_rotation_t const rotation) {
    return OLED_ROTATION_0;
}

bool oled_task_user(void) {
    render_bongocat();
    return false;
}
